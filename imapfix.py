#!/usr/bin/env python

# ImapFix v1.31 (c) 2013-15 Silas S. Brown.  License: GPL

# Put your configuration into imapfix_config.py,
# overriding these options:

hostname = "imap4-ssl.example.org"
username = "me"
password = "xxxxxxxx"
login_retry = False # True = don't stop on login failure
# (useful if your network connection is not always on)

filtered_inbox = "in" # or =None if you don't want to do
# any moving from inbox to filtered_inbox (i.e. no rules)
# but just use maildirs_to_imap or maildir_to_copyself,
# e.g. because you're on an auxiliary machine (which does
# not have your spamprobe database etc) but still want to
# use maildir_to_copyself for mutt (see notes below)

leave_note_in_inbox = True # for "new mail" indicators

newmail_directory = None
# or newmail_directory = "/path/to/a/directory"
# - any new mail put into any folder by header_rules will
# result in a file being created in that local directory
# with the same name as the folder

max_size_of_first_part = 48*1024
# any messages whose first part is longer than this will be
# converted into attachments.  This is for sync'ing in
# bandwidth-limited situations using a device that knows to
# not fetch attachments but doesn't necessarily know to not
# fetch more than a certain amount of text (especially if
# it's only HTML).

image_size = None # or e.g. image_size = (320,240)
# - adds scaled-down versions of any image attachment that
# exceeds this size, for previewing on low bandwidth
# (this option requires the PIL library).  The scaled-down
# versions are added only if the file is actually smaller.

header_rules = [
    ("folder-name-1",
     ["regexp to check for in header",
      "regexp to check for in header",
      "regexp to check for in header"]),
    ("folder-name-2",
     ["regexp to check for in header"]),
    # etc; folder name None = delete the message;
    # "inbox" = change to filtered_inbox;
    # "spam" = change to spam_folder;
    # start with a * if this folder does not need any
    # notification in newmail_directory
]

def extra_rules(message_as_string): return False
# you can override this to any function you want, which
# returns the name of a folder, or None to delete the
# message, or False = no decision
catch_extraRules_errors = True

def handle_authenticated_message(subject,firstPart,attach):
    return False
# - you can override this to any function you want, which
# does anything you want in response to messages that are
# SSL-authenticated as coming from yourself (see below).
# Returns the name of a folder, or None to delete the
# message, or False = undecided (normal rules will apply).
# If folder name starts with *, mail will be marked 'seen'.
# firstPart is a UTF-8 copy of the first part of the body
# (which will typically contain plain text even if you
# were using an HTML mailer); subject is also UTF-8 coded.
# attach is a dictionary of filename:contents.
trusted_domain = None # or e.g. ".example.org" specifying
# the domain of "our" network whose Received headers we
# can trust for SMTPS authentication (below)
smtps_auth = None # or e.g. " with esmtpsa (LOGIN:me)"
# - if a Received header generated by your trusted domain
# (and listed before any untrusted headers) contains this
# string, the message is considered authentically from you
# (this string should be generated by your network only if
# you really did authenticate over HTTPS).  You may also
# set smtps_auth to a list of strings, any one of which is
# acceptable, e.g. smtps_auth=["esmtpsa (LOGIN:me)","esmtpsa (PLAIN:me)"]
# Note: if trusted_domain and smtps_auth is set, any message
# that does NOT contain any Received headers will be assumed
# to be generated from your own account and therefore treated
# as though it had been authenticated by smtps_auth (which
# might be useful for using --multinote with the real inbox).
# You should therefore ensure that your local network ALWAYS
# adds at least one Received header to incoming mail.

# If handle_authenticated_message needs to send other mail
# via SMTP, it can call
# send_mail(to,subject_u8,txt,attachment_filenames=[],copyself=True)
# if the following SMTP options are set:
smtp_fromHeader = "Example Name <example@example.org>"
smtp_fromAddr = "example@example.org"
smtp_host = "localhost"
smtp_user = ""
smtp_password = ""
smtp_delay = 60 # seconds between each message
# (These smtp_ settings are not currently used by anything
# except user-supplied handle_authenticated_message functions)

spamprobe_command = "spamprobe -H all" # (or = None)
spam_folder = "spam"

poll_interval = 4*60
# Note: set poll_interval=False if you want just one run,
# or poll_interval="idle" to use imap's IDLE command (this
# requires the imaplib2 module).

logout_before_sleep = False # suggest set to True if using
# a long poll_interval, or if filtered_inbox=None

midnight_command = None
# or, daily_command = "system command to run at midnight"
# (useful if you don't have crontab access on the machine)

quiet = True # False = print messages (including quota)
# If you set quiet = 2, will be quiet if and only if the
# standand output is not connected to a terminal

maildirs_to_imap = None # or path to a local directory of
# maildirs; messages will be moved to their corresponding
# folders on IMAP (renaming inbox to filtered_inbox
# and spam to spam_folder, and converting character sets)
maildir_colon = ':'

maildir_to_copyself = None # or path to a maildir whose
# messages should be moved to imap's copyself (for example if
# mutt is run on the same machine and saves its messages
# locally, which is more responsive than uploading to imap,
# but you still want them to be uploaded to imap eventually)
copyself_delete_attachments = False # if True, attachments
# are DELETED when moving from maildir_to_copyself to the
# IMAP folder (but a record is still kept of what was
# attached, unlike the fcc_attach='no' setting in Mutt 1.5)
copyself_folder_name = "Sent Items"
copyself_alt_folder = None # or the name of an IMAP folder
# - any messages found in here (if folder exists) will be
# moved to copyself_folder_name, with their attachments
# deleted if copyself_delete_attachments is True.  You can
# specify more than one folder by separating them with a
# comma.  Might be useful if some of your IMAP programs
# insist on doing their own sent-mail filing to folders of
# their own choice rather than yours.

archive_path = "oldmail"
archive_rules = [
    # These rules are used when you run with --archive
    # Each rule is: ("folder-name", max-age (days), spamprobe-action)
    # If max-age specified, older messages will be archived.  Independently of this, spamprobe-action (if specified) will be run on all messages.
    ("spam-confirmed", 30, "train-spam"),
    ("some-folder", 90, None),
    ("some-other-folder", None, "train-good"),
    ]
compression = "bz2" # or "gz" or None
archived_attachments_path = "archived-attachments" # or None
attachment_filename_maxlen = 30

forced_names = {} # you can set this to a dictionary
# mapping email address to From name, and whatever other
# From name is used will be replaced by the one specified;
# this is for when one of your contacts has their "From"
# name set to something confusing like their ISP's name

# Set secondary_imap_hostname if you also want to check
# some other IMAP server and treat its messages as being
# in the inbox of the main server (i.e. copied over and
# processed as normal).  You can check this less often by
# setting secondary_imap_delay.  (Will not stay logged in
# between checks.)
secondary_imap_hostname = ""
secondary_imap_username = "me"
secondary_imap_password = "xxxxxxxx"
secondary_imap_delay = 24 * 3600

exit_if_imapfix_config_py_changes = False # if True, does
# what it says, on the assumption that a wrapper script
# will restart it (TODO: make it restart by itself?)

failed_address_to_subject = True # try to rewrite delivery
# failure reports so that failed addresses are included in
# the Subject line and are therefore visible from a table
# of subjects without having to go in to the message.
# Not all delivery failure reports can be adjusted in this
# way; it depends on how the bouncing relay formats them.

exit_if_other_running = True # when run without options,
# try to detect if another no-options imapfix is running
# as the same user, and exit if so.  Not guaranteed (for
# example, it can't protect against instances being run on
# different machines of a cluster), but might help to
# reduce the build-up of processes if there is a runaway
# situation with whatever you're using to start them.
# Multiple imapfix instances are sort-of OK but may lead
# to messages being processed in duplicate and/or load the
# IMAP server too much; on the other hand lock files etc
# can have the problem of 'stale' locks.  At least a limit
# of 1 process per server in the cluster is better than no
# limit at all.  On the other hand you might want to set
# this to False if you run different instances of imapfix
# with different configuration files as the same user and
# don't want to rename (or symlink) imapfix so that these
# look different in the process table.
# (exit_if_other_running needs the Unix 'ps' command.)

alarm_delay = 0 # with some Unix networked filesystems it is
# possible for imapfix or one of its subprocesses to get
# "stuck" - if this happens, set alarm_delay to a number of
# seconds (preferably thousands) after which to terminate the
# process using the Unix "alarm clock" mechanism.  The clock
# will be reset every half that number of seconds if imapfix
# is still functioning.  Note that a long-running filter etc
# could also cause imapfix to become "stuck" this long.

# Command-line options
# --------------------

# Run with no options = process mail as normal

# Run with --once = as if poll_interval=False

# Run with --quicksearch (search string) to search both
# archive_path and the server (all folders), but "quick"
# in that it doesn't decode MIME attachments etc
# (TODO: implement more thorough search, with regexps, but
# it would have to download all messages from the server)

# Run with --delete (folder name) to delete a folder

# Run with --note (subject) to put a note to yourself
# (taken from standard input) directly into filtered_inbox
# - useful from scripts etc (you can get the note without
# having to wait for it to go through SMTP and polling).
# (If filtered_inbox is None, --note uses real inbox)
# Run with --htmlnote to do the same but send as HTML.
# Run with --maybenote to do --note only if standard input
# has text (no mail left if your script printed nothing).

# Run with --multinote (files) to transfer a group of text
# files into filtered_inbox notes.  The first line of each
# file is the subject line of the note.  Files will be
# deleted after being successfully uploaded to IMAP.
# Directories are processed recursively but not deleted.
# Backup files (with names ending ~) are deleted without
# being uploaded to IMAP.
# If handle_authenticated_message has been redefined, this
# will be called as well when using --multinote.  (If you
# are using this function on a machine that is different
# from the one that does your mail processing, you may
# want to define handle_authenticated_message to
# return "" which will result in the messages being placed
# in the real inbox for processing by the other machine.
# Alternatively you can use --multinote-inbox for the same effect.)

# All note options assume that any non-ASCII characters in
# the input will be encoded as UTF-8.

# End of options - non-developers can stop reading now :)
# -------------------------------------------------------

# CHANGES
# -------
# If you want to compare this code to old versions, most old
# versions are being kept on SourceForge's E-GuideDog SVN repository
# http://sourceforge.net/p/e-guidedog/code/HEAD/tree/ssb22/setup/
# To check out the repository, you can do:
# svn co http://svn.code.sf.net/p/e-guidedog/code/ssb22/setup

from imapfix_config import *
if poll_interval=="idle":
    import imaplib2 as imaplib
    assert not logout_before_sleep, "Can't logout_before_sleep when poll_interval==\"idle\""
else:
    import imaplib

if filtered_inbox==None: spamprobe_command = None

import email,email.utils,time,os,sys,re,base64,quopri,mailbox,traceback
from cStringIO import StringIO

if compression=="bz2":
    import bz2
    compression_ext = ".bz2"
elif compression=="gz":
    import gzip
    compression_ext = ".gz"
else: compression_ext = ""

if image_size: from PIL import Image

def debug(msg):
    if not quiet: print msg
    
def check_ok(r):
    "Checks that the return value of an IMAP call 'r' is OK, raises exception if not"
    typ, data = r
    if not typ=='OK': raise Exception(typ+' '+repr(data))

def spamprobe_rules(message):
  if run_spamprobe("train",message).startswith("SPAM"): return spam_folder # classify + maybe update database
  else: return filtered_inbox

def run_spamprobe(action,message):
  if not spamprobe_command: return ""
  cIn, cOut = os.popen2(spamprobe_command+" "+action)
  cIn.write(message); cIn.close()
  return cOut.read()

def spamprobe_cleanup():
    if not spamprobe_command: return
    debug("spamprobe cleanup")
    os.system(spamprobe_command+" cleanup")

def process_header_rules(header):
  for box,matchList in header_rules:
    for headerLine in header.split("\n"):
      for m in matchList:
        i=re.finditer(m,headerLine.rstrip())
        try: i.next()
        except StopIteration: continue
        if box and box[0]=='*': box=box[1:] # just save it without indication
        elif box: open(newmail_directory+os.sep+box,'a')
        return rename_folder(box)
  return False

def myAsString(msg):
    message = msg.as_string()
    if not "\r\n\r\n" in message:
        # oops, broken library?
        message=message.replace("\n\n","\r\n\r\n",1)
        a,b = message.split("\r\n\r\n")
        message = re.sub('\r*\n','\r\n',a)+"\r\n\r\n"+b
    return message

imapfix_name = sys.argv[0]
if os.sep in imapfix_name: imapfix_name=imapfix_name[imapfix_name.rindex(os.sep)+1:]
if not imapfix_name: imapfix_name = "imapfix.py"
# used both in From line and by other_running()

def authenticated_wrapper(subject,firstPart,attach={}):
    try: r=handle_authenticated_message(subject,firstPart,attach)
    except:
        if not catch_extraRules_errors: raise # TODO: document it's also catch_authMsg_errors, or have another variable for that
        o = StringIO() ; traceback.print_exc(None,o)
        save_to(filtered_inbox,"From: "+imapfix_name+"\r\nSubject: imapfix_config exception in handle_authenticated_message, treating it as return False\r\nDate: %s\r\n\r\n%s\n" % (email.utils.formatdate(time.time()),o.getvalue()))
        r=False
    return r

def yield_all_messages():
    typ, data = imap.search(None, 'ALL')
    if not typ=='OK': raise Exception(typ)
    for msgID in data[0].split():
        typ, data = imap.fetch(msgID, '(FLAGS)')
        if not typ=='OK': continue
        if '\\Deleted' in data[0]: continue # we don't mark messages deleted until they're processed; if imapfix was interrupted in the middle of a run, then don't process this message a second time
        typ, data = imap.fetch(msgID, '(RFC822)')
        if not typ=='OK': continue
        yield msgID, data[0][1] # data[0][0] is e.g. '1 (RFC822 {1015}'

def rewrite_deliveryfail(msg):
    if not failed_address_to_subject: return
    subj = msg.get("Subject","")
    if not subj.lower().startswith("mail delivery") or not msg.get("From","").lower().startswith("mail delivery"): return
    fr = msg.get("X-Failed-Recipients","")
    if not fr: return
    del msg['Subject'] ; msg['Subject']=fr+' '+subj
    return True

for k in forced_names.keys():
    if not k==k.lower():
        forced_names[k.lower()]=forced_names[k]
        del forced_names[k]
def forced_from(msg):
    def f(fr):
        if fr.lower() in forced_names:
            msg["From"] = forced_names[fr.lower()] + ' <'+fr.lower()+'>'
            return True
    fr = msg.get("From","").strip()
    if f(fr): return True
    if fr.endswith('>') and '<' in fr and f(fr[fr.rindex('<')+1:-1]): return True
    # TODO: any other formats to check?

def process_imap_inbox():
    make_sure_logged_in()
    check_ok(imap.select()) # the inbox
    imapMsgid = None ; newMail = False
    for msgID,message in yield_all_messages():
        if leave_note_in_inbox and imap==saveImap and isImapfixNote(message):
            if imapMsgid: # somehow ended up with 2, delete one
                imap.store(imapMsgid, '+FLAGS', '\\Deleted')
            imapMsgid = msgID ; continue
        msg = email.message_from_string(message)
        box = False ; seenFlag=""
        if authenticates(msg):
          # do auth'd-msgs processing before any convert-to-attachment etc
          debug("Message authenticates")
          box = authenticated_wrapper(re.sub(header_charset_regex,header_to_u8,msg.get("Subject",""),flags=re.DOTALL),getFirstPart(msg).lstrip(),get_attachments(msg))
          if box and box[0]=='*':
              box=box[1:] ; seenFlag="\\Seen"
        if not box==None:
         # globalise charsets BEFORE the filtering rules
         # (especially if they've been developed based on
         # post-charset-conversion saved messages)
         changed = globalise_charsets(msg)
         if image_size: changed = add_previews(msg) or changed
         changed = rewrite_deliveryfail(msg) or changed
         changed = forced_from(msg) or changed
         if max_size_of_first_part and size_of_first_part(msg) > max_size_of_first_part: msg,changed = turn_into_attachment(msg),True
         if changed: message = myAsString(msg)
         if box==False:
          header = message[:message.find("\r\n\r\n")]
          box = process_header_rules(header)
          if box==False:
            try: box = rename_folder(extra_rules(message))
            except:
                if not catch_extraRules_errors: raise
                o = StringIO() ; traceback.print_exc(None,o)
                save_to(filtered_inbox,"From: "+imapfix_name+"\r\nSubject: imapfix_config exception in extra_rules (message has been saved to '%s')\r\nDate: %s\r\n\r\n%s\n" % (filtered_inbox,email.utils.formatdate(time.time()),o.getvalue()))
                box = filtered_inbox
            if box==False: box = spamprobe_rules(message)
        if box:
            debug("Saving message to "+box)
            save_to(box, message, seenFlag)
            if box==filtered_inbox: newMail = True
        else: debug("Deleting message")
        imap.store(msgID, '+FLAGS', '\\Deleted')
    if leave_note_in_inbox and imap==saveImap:
      if newMail:
        if imapMsgid: # delete the old one
            imap.store(imapMsgid, '+FLAGS', '\\Deleted')
        save_to("", imapfixNote())
      elif imapMsgid:
        # un-"seen" it (in case the IMAP server treats our fetching it as "seen"); TODO what if the client really read it but didn't delete?
        imap.store(imapMsgid, '-FLAGS', '\\Seen')
    check_ok(imap.expunge())
    if (not quiet) and imap==saveImap: debug("Quota "+repr(imap.getquotaroot(filtered_inbox)[1])) # RFC 2087 "All mailboxes that share the same named quota root share the resource limits of the quota root" - so if the IMAP server has been set up in a typical way with just one limit, this command should print the current and max values for that shared limit.  (STORAGE = size in Kb, MESSAGE = number)

def authenticates(msg):
    if not trusted_domain or not smtps_auth: return
    rxd = msg.get_all("Received",[])
    if not rxd: return True # no Received headers = put in by imapfix on another machine
    for rx in rxd:
      rx = re.sub(r'\s+',' ',rx)
      m=re.match(r"from ([^ ]+) (\([^)]*\))? by ([^ ]+)",rx)
      if not m: break
      if not m.groups()[-1].endswith(trusted_domain): break # receiving machine does not even claim to be on our net
      rx = rx[m.end():].strip()
      if rx.startswith('('): # ignore this bit (don't allow injection of smtps_auth into HELO/EHLO strings)
          if not ')' in rx: break # ?!?
          rx=rx[rx.index(')')+1:]
      if type(smtps_auth)==list:
          if any(s in rx for s in smtps_auth): return True
      elif smtps_auth in rx: return True
      if not m.groups()[0].endswith(trusted_domain): break # next-older hop is not on our net - stop trusting, no matter what is claimed in further Received headers

def imapfixNote(): return "From: "+imapfix_name+"\r\nSubject: Folder "+repr(filtered_inbox)+" has new mail\r\nDate: "+email.utils.formatdate(time.time())+"\r\n\r\n \n" # make sure there's at least one space in the message, for some clients that don't like empty body
# (and don't put a date in the Subject line: the message's date is usually displayed anyway, and screen space might be in short supply)
def isImapfixNote(msg): return ("From: "+imapfix_name) in msg and ("Subject: Folder "+repr(filtered_inbox)+" has new mail") in msg

def archive(foldername, mboxpath, age, spamprobe_action):
    if age:
      if spamprobe_action: extra = ", spamprobe="+spamprobe_action
      else: extra = ""
      toDbg="Archiving from "+foldername+" to "+mboxpath+extra+"..."
      suf = "" ; sc = 0
      while os.path.exists(mboxpath+suf+compression_ext):
        sc += 1 ; suf = "."+str(sc)
      while sc:
        if sc==1: suf = ""
        else: suf = "."+str(sc-1)
        suf2 = "."+str(sc)
        os.rename(mboxpath+suf+compression_ext,
                  mboxpath+suf2+compression_ext)
        sc -= 1
      mbox = mailbox.mbox(mboxpath) # will compress below
    else:
      toDbg = "Processing "+foldername+"..."
      mbox = None
    make_sure_logged_in() ; debug(toDbg)
    typ, data = imap.select(foldername)
    if not typ=='OK': return # couldn't select that folder
    for msgID,message in yield_all_messages():
        if spamprobe_action:
            # TODO: combine multiple messages first?
            run_spamprobe(spamprobe_action, message)
        if not age: continue
        msg = email.message_from_string(message)
        if 'Date' in msg: t = email.utils.mktime_tz(email.utils.parsedate_tz(msg['Date']))
        else: t = time.time() # undated message ??
        if t >= time.time() - age: continue
        if not message.startswith("From "): # needed for Unix mbox, otherwise mbox lib fills it in with MAILER-DAEMON
            f = []
            if 'From' in msg:
                fr = msg['From']
                if '<' in fr and '>' in fr[fr.index('<'):]:
                    fr = fr[fr.index('<')+1:fr.rindex('>')]
                if not fr: fr = 'unknown'
                f.append(fr)
                f.append(time.asctime(time.gmtime(t))) # must be THIS format for at least some versions of mutt to parse the message
                message="From "+' '.join(f)+"\r\n"+message
                msg = email.message_from_string(message)
        globalise_charsets(msg) # in case wasn't done on receive (this also makes sure UTF-8 is quopri if it would be shorter, which can make archives easier to search)
        if archived_attachments_path:
            save_attachments_separately(msg)
        mbox.add(msg) # TODO: .set_flags A=answered R=read ?  (or doesn't it matter so much for old-message archiving; flags aren't always right anyway as you might have answered some using another method)
        imap.store(msgID, '+FLAGS', '\\Deleted')
    if mbox:
        mbox.close()
        if not os.stat(mboxpath).st_size: os.remove(mboxpath) # ended up with an empty file - delete it
        elif compression:
            open_compressed(mboxpath,'wb').write(open(mboxpath,'rb').read()) # will write a .bz2 etc
            os.remove(mboxpath)
    # don't do this until got here without error:
    check_ok(imap.expunge())

def fix_archives_written_by_imapfix_v1_308():
    for f in listdir(archive_path):
        f = archive_path+os.sep+f
        if f.endswith(compression_ext): f2 = open_compressed(f[:-len(compression_ext)],'r')
        else: f2 = open(f)
        r = [] ; changed = False
        for l in f2:
          if l.startswith("From "):
            l2 = l.replace('<','')
            try: t = email.utils.mktime_tz(email.utils.parsedate_tz(' '.join(l2.split()[-6:])))
            except: t = None
            if t:
                l2 = ' '.join(l2.split()[:-6])+' '+time.asctime(time.gmtime(t))+'\r\n'
                r.append(l2) ; changed = True ; continue
          r.append(l)
        if changed:
          print "Fixing",f
          if f.endswith(compression_ext): open_compressed(f[:-len(compression_ext)],'wb').write(''.join(r))
          else: open(f,'wb').write(''.join(r))
        else: print "No need to fix",f

def get_attachments(msg):
    if msg.is_multipart():
        d = {}
        for i in msg.get_payload():
            d.update(get_attachments(i))
        return d
    try: fname = msg.get_filename()
    except: fname="illegal-filename"
    if not fname: return {}
    data = msg.get_payload(None,True)
    if data: return {fname:data}
    else: return {}

def save_attachments_separately(msg):
    if msg.is_multipart():
        for i in msg.get_payload():
            save_attachments_separately(i)
        return
    try: fname = msg.get_filename()
    except: fname="illegal-filename-A"
    if not fname: return
    try: fname=fname.encode("us-ascii") # (or utf-8 if the filesystem definitely supports it)
    except: fname="illegal-filename-B"
    if '.' in fname: fext = fname[fname.rindex('.'):]
    else: fext = ""
    if len(fext) > attachment_filename_maxlen:
        fname = fname[:attachment_filename_maxlen]
    else:
        if fext: fname = fname[:-len(fext)]
        fname = fname[:attachment_filename_maxlen-len(fext)] + fext
    data = msg.get_payload(None,True)
    if not data: return
    msg.set_payload("")
    try: os.mkdir(archived_attachments_path)
    except: pass # OK if exists
    f2 = archived_attachments_path+os.sep+fname
    suffix = "" ; sufCount = 0
    while os.path.exists(f2+suffix+compression_ext):
        if open_compressed(f2+suffix,'rb').read() == data:
            # it's a duplicate - keep what we already have
            return
        sufCount += 1 ; suffix = "."+str(sufCount)
    open_compressed(f2+suffix,'wb').write(data)

def delete_attachments(msg):
    if msg.is_multipart():
        for i in msg.get_payload():
            delete_attachments(i)
    elif msg.get_filename(): msg.set_payload("")

def open_compressed(fname,mode):
    if compression=="bz2":
        return bz2.BZ2File(fname+".bz2",mode)
        # (compresslevel default is 9)
    elif compression=="gz":
        return gzip.open(fname+".gz",mode)
        # (again, compresslevel default is 9)
    elif compression: raise Exception("Unrecognised compression type") # essential, as archive() assumes it can delete the original file after calling open_compressed
    return open(fname,mode)

already_created = set()
def save_to(mailbox, message_as_string,
            flags="", received_time = None):
    "Saves message to a mailbox on the saveImap connection, creating the mailbox if necessary"
    make_sure_logged_in()
    if mailbox and not mailbox in already_created:
        saveImap.create(mailbox) # error if exists OK
        already_created.add(mailbox)
    if not received_time: received_time = time.time()
    check_ok(saveImap.append(mailbox, flags, imaplib.Time2Internaldate(received_time), message_as_string))

def rename_folder(folder):
    if not isinstance(folder,str): return folder
    if folder.lower()=="inbox":
        return filtered_inbox
    elif folder.lower()=="spam": return spam_folder
    else: return folder

def listdir(d): return sorted(os.listdir(d))

def do_maildirs_to_imap():
    mailbox.Maildir.colon = maildir_colon
    for d in listdir(maildirs_to_imap):
        d2 = maildirs_to_imap+os.sep+d
        if not os.path.exists(d2+os.sep+"cur"):
            continue # not a maildir
        to = rename_folder(d)
        debug("Moving messages from maildir "+d+" to imap "+to)
        m = mailbox.Maildir(d2,None)
        for k,msg in m.items():
            globalise_charsets(msg)
            if 'Date' in msg: t = email.utils.mktime_tz(email.utils.parsedate_tz(msg['Date']))
            else: t = None # undated message ??
            save_to(to,myAsString(msg),imap_flags_from_maildir_msg(msg),t)
            del m[k]
        newcurtmp = ["new","cur","tmp"]
        if not any(listdir(d2+os.sep+ntc) for ntc in newcurtmp): # folder is now empty: remove it
            for nct in newcurtmp: os.rmdir(d2+os.sep+nct)
            os.rmdir(d2)

def imap_flags_from_maildir_msg(msg): return " ".join(" ".join({'S':r'\Seen','D':r'\Deleted','R':r'\Answered','F':r'\Flagged'}.get(flag,"") for flag in msg.get_flags()).split())

def do_maildir_to_copyself():
    mailbox.Maildir.colon = maildir_colon
    m = mailbox.Maildir(maildir_to_copyself,None)
    said = False
    for k,msg in m.items():
        if not said:
            debug("Moving messages from "+maildir_to_copyself+" to imap "+copyself_folder_name)
            said = True
        globalise_charsets(msg)
        if 'Date' in msg: t = email.utils.mktime_tz(email.utils.parsedate_tz(msg['Date']))
        else: t = None # undated message ??
        if copyself_delete_attachments:
            delete_attachments(msg)
        save_to(copyself_folder_name,myAsString(msg),imap_flags_from_maildir_msg(msg),t)
        del m[k]

def do_copyself_to_copyself():
    for folder in copyself_alt_folder.split(","):
        if folder==copyself_folder_name:
            debug("Cannot specify copyself_folder_name in copyself_alt_folder: skipping "+folder)
            continue
        make_sure_logged_in()
        typ, data = imap.select(folder)
        if not typ=='OK':
            debug("Skipping non-selectable folder "+folder)
            continue
        said = False
        for msgID,message in yield_all_messages():
            if not said: # don't say until we know there's at least some messages in the folder
                debug("Moving messages from "+folder+" to "+copyself_folder_name)
                said = True
            msg = email.message_from_string(message)
            globalise_charsets(msg)
            if 'Date' in msg: t = email.utils.mktime_tz(email.utils.parsedate_tz(msg['Date']))
            else: t = None # undated message ??
            if copyself_delete_attachments:
                delete_attachments(msg)
            save_to(copyself_folder_name,myAsString(msg),"\\Seen",t)
            imap.store(msgID, '+FLAGS', '\\Deleted')
        check_ok(imap.expunge())

header_charset_regex = r'=\?(.*?)\?(.*?)\?(.*?)\?='
def header_to_u8(match):
    charset = match.group(1).lower()
    if charset in ['gb2312','gbk']: charset='gb18030'
    encoding = match.group(2)
    text = match.group(3)
    try:
        if encoding.upper()=='Q': text = quopri.decodestring(text,header=True)
        else: text = base64.decodestring(text)
        text = text.decode(charset)
    except:
        debug("Bad header line: exception decoding "+repr(text)+" in "+charset+", leaving unchanged")
        return match.group()
    return text.encode('utf-8')
def globalise_header_charset(match):
    #if match.group(1).lower()=="utf-8":
    #    return match.group() # no changes needed
    # - actually, do it anyway, because some UTF8 headers might be
    # quopri-encoded when they're only ASCII, etc, and "normalising"
    # these might help the writing of filtering rules
    hu8 = header_to_u8(match)
    if hu8 == match: return hu8 # something went wrong; at least don't double-encode it
    return utf8_to_header(hu8)
def utf8_to_header(u8):
    if u8.startswith('=?') or re.search(r"[^ -~]",u8):
        ret = "B?"+base64.encodestring(u8).replace("\n","")
        qp = "Q?"+re.sub("=?\n","",quopri.encodestring(u8,header=True)).replace('?','=3F') # must have header=True for alpine (although mutt and Outlook etc may work either way, especially if the with-spaces version is not wrapped, but alpine fails to decode the quopri if any space is present)
        if len(qp) <= len(ret): ret = qp
        return "=?UTF-8?"+ret+"?="
    else: return u8 # ASCII and no encoding needed

import email.mime.multipart,email.mime.message,email.mime.text,email.mime.image,email.charset,email.mime.base
def turn_into_attachment(message):
    m2 = email.mime.multipart.MIMEMultipart()
    for k,v in message.items():
        if not k.lower() in ['content-length','content-type','content-transfer-encoding','lines']: m2[k]=v
    m2.attach(email.mime.text.MIMEText("Large message converted to attachment")) # by imapfix, but best not mention this as it might bias the filters?
    m2.attach(email.mime.message.MIMEMessage(message))
    return m2
def size_of_first_part(message):
    if message.is_multipart():
        for i in message.get_payload():
            return size_of_first_part(i)
        return 0
    return len(message.get_payload())

def getFirstPart(message):
    if message.is_multipart():
        for i in message.get_payload():
            return getFirstPart(i)
        return ""
    try: pl = message.get_payload(decode=True)
    except: return ""
    cs = message.get_content_charset(None)
    if cs in [None,'us-ascii','utf-8']: return pl
    if cs in ['gb2312','gbk']: cs = 'gb18030'
    return pl.decode(cs).encode('utf-8')

def globalise_charsets(message):
    """'Globalises' the character sets of all parts of
        email.message.Message object 'message'.
        Only us-ascii and utf-8 charsets are 'global'.
        Also tries to use quoted-printable rather than
        base64 if doing so won't increase the length.
        Returns True if any changes were made."""
    changed = False
    for line in ["From","To","Cc","Subject","Reply-To"]:
        if not line in message: continue
        l = message[line]
        l2 = re.sub(header_charset_regex,globalise_header_charset,l,flags=re.DOTALL).replace('\n',' ').replace('\r','') # the \n and \r replacements are in case the original header is corrupt
        if l==l2: continue
        # debug("Setting "+line+" to "+repr(l2))
        del message[line]
        message[line] = l2
        changed = True
    if message.is_multipart():
        for i in message.get_payload():
            if globalise_charsets(i): changed = True
        return changed
    m = message.get_content_charset(None)
    if m in [None,'us-ascii','utf-8'] and (not 'Content-Transfer-Encoding' in message or message['Content-Transfer-Encoding']=='quoted-printable'): return changed # no further conversion required
    if m in ['gb2312','gbk']: m = 'gb18030'
    try: p = message.get_payload(decode=True).decode(m)
    except: return changed # problems decoding this message
    if message.get_content_type()=="text/html":
        q = '[\'"]' # could use either " or ' quotes
        p = re.sub(r'(?i)<meta\s+http[_-]equiv='+q+r'?content-type'+q+r'?\s+content='+q+'[^\'"]*'+q+r'>','',p) # better remove charset meta tags after we changed the charset (TODO: what if they conflict with the message header anyway?)
    p = p.encode('utf-8')
    if 'Content-Transfer-Encoding' in message:
        isQP = (message['Content-Transfer-Encoding']=='quoted-printable')
        del message['Content-Transfer-Encoding']
    else: isQP = False
    if isQP or len(quopri.encodestring(p)) <= len(base64.encodestring(p)): email_u8_quopri()
    else: email_u8_default()
    message.set_payload(p,'utf-8')
    email_u8_default() # just in case
    return True # charset changed
def email_u8_quopri(): email.charset.add_charset('utf-8',email.charset.SHORTEST,email.charset.QP,'utf-8') # use Quoted-Printable rather than Base64 for UTF-8 if the original was quopri or if doing so is shorter (besides anything else it's easier to search emails without tools that way)
def email_u8_default(): email.charset.add_charset('utf-8',email.charset.SHORTEST,email.charset.BASE64,'utf-8')

def add_previews(message,parent=None,accum=None):
    changed = False
    if message.is_multipart():
        if parent: p0 = parent
        else:
            p0 = message ; accum = []
        for i in message.get_payload():
            if add_previews(i,p0,accum): changed = True
        if not parent:
            for i in accum: message.attach(i)
        return changed
    if not 'Content-Type' in message or message["Content-Type"].startswith("text/"): return False
    payload = message.get_payload(decode=True)
    try: img=Image.open(StringIO(payload))
    except: return False # not an image, or corrupt
    img.thumbnail(image_size,Image.ANTIALIAS)
    s1 = StringIO();img.save(s1,'JPEG');s1=s1.getvalue()
    s2 = StringIO();img.save(s2,'PNG'); s2=s2.getvalue()
    if len(s2) > len(s1): s,ext = s1,"jpg"
    else: s,ext = s2,"png"
    if len(s) > len(payload): return # we failed to actually compress the image
    accum.append(email.mime.image.MIMEImage(s))
    accum[-1]['Content-Disposition']='attachment; filename=imapfix-preview'+str(len(accum))+'.'+ext # needed for some clients to show it
    return True

setAlarmAt = 0
def checkAlarmDelay():
    global setAlarmAt
    if time.time() > setAlarmAt:
        import signal
        signal.setitimer(signal.ITIMER_REAL,alarm_delay)
        setAlarmAt = time.time() + alarm_delay/2

def mainloop():
  newDay = oldDay = time.localtime()[:3] # for midnight
  done_spamprobe_cleanup = False
  secondary_imap_due = 0
  if exit_if_imapfix_config_py_changes:
    mtime = os.stat("imapfix_config.py").st_mtime
  try:
   while True:
    if alarm_delay: checkAlarmDelay()
    if maildirs_to_imap: do_maildirs_to_imap()
    if maildir_to_copyself: do_maildir_to_copyself()
    if copyself_alt_folder: do_copyself_to_copyself()
    if filtered_inbox:
        process_imap_inbox()
        if time.time() > secondary_imap_due and secondary_imap_hostname:
            process_secondary_imap()
            secondary_imap_due = time.time() + secondary_imap_delay
    if logout_before_sleep: make_sure_logged_out()
    if not poll_interval: break
    if not done_spamprobe_cleanup:
        spamprobe_cleanup()
        done_spamprobe_cleanup = True
    if poll_interval=="idle":
        debug("Waiting for IMAP event") ; imap.idle()
        # Can take a timeout parameter, default 29 mins.  TODO: allow shorter timeouts for clients behind NAT boxes or otherwise needing more keepalive?  IDLE can still be useful in these circumstances if the server's 'announce interval' is very short but we don't want across-network polling to be so short, e.g. slow link (however you probably don't want to be running imapfix over slow/wobbly links - it's better to run it on a well-connected server)
    else:
        debug("Sleeping for "+str(poll_interval)+" seconds")
        time.sleep(poll_interval)
         # TODO catch imap connection errors and re-open?  or just put this whole process in a loop
    newDay = time.localtime()[:3]
    if not oldDay==newDay:
      oldDay=newDay
      if midnight_command: os.system(midnight_command)
      done_spamprobe_cleanup = False
    if exit_if_imapfix_config_py_changes and not near_equal(mtime,os.stat("imapfix_config.py").st_mtime): break
  finally: make_sure_logged_out()

def near_equal(time1,time2):
    # allow small difference due to filesystem quirks
    # (e.g. if the server caches file times at a higher
    # resolution than the underlying filesystem, which can
    # be the case in some Linux+NetWare setups)
    if time1 > time2: time2,time1 = time1,time2
    return (time2-time1) <= 5

def process_secondary_imap():
    global imap
    try:
        imap = imaplib.IMAP4_SSL(secondary_imap_hostname)
        check_ok(imap.login(secondary_imap_username,secondary_imap_password))
    except:
        debug("Could not log in to secondary IMAP: skipping it this time")
        imap = None
    if imap: process_imap_inbox()
    imap = saveImap

def do_archive():
    try: os.mkdir(archive_path)
    except: pass # no error if exists
    for foldername,age,action in archive_rules:
        if age: age = age*24*3600
        archive(foldername, archive_path+os.sep+foldername, age, action)

def yield_folders():
    "iterates through folders in imap, selecting each one as it goes"
    make_sure_logged_in()
    for foldername in imap.list()[1]:
        if '"/"' in foldername: foldername=foldername[foldername.index('"/"')+3:].lstrip()
        if foldername.startswith('"') and foldername.endswith('"'): foldername=foldername[1:-1] # TODO: check if any other unquoting is needed
        typ, data = imap.select(foldername)
        if not typ=='OK': continue
        yield foldername

def do_note(subject,ctype="text/plain",maybe=0):
    subject = subject.strip()
    if not subject: subject = "Note to self (via imapfix)"
    if isatty(sys.stdin):
        sys.stderr.write("Type the note, then EOF\n")
    body = sys.stdin.read()
    if not body:
        if maybe: return
        body = " " # make sure there's at least one space in the message, for some clients that don't like empty body
    if filtered_inbox==None: saveTo = ""
    else: saveTo = filtered_inbox
    save_to(saveTo,"From: "+imapfix_name+"\r\nSubject: "+utf8_to_header(subject)+"\r\nDate: "+email.utils.formatdate(time.time())+"\r\nMIME-Version: 1.0\r\nContent-type: "+ctype+"; charset=utf-8\r\n\r\n"+from_mangle(body)+"\n")
def from_mangle(body): return re.sub('(?<![^\n])From ','>From ',body) # (Not actually necessary for IMAP, but might be useful if the message is later processed by something that expects a Unix mailbox.  Could MIME-encode instead, but not so convenient for editing.)

def multinote(filelist,to_real_inbox):
    if not filtered_inbox: to_real_inbox = True
    for f in filelist:
        if os.path.isdir(f):
            multinote([(f+os.sep+g) for g in listdir(f)],to_real_inbox)
            continue
        if not os.path.isfile(f):
            debug("Ignoring non-file non-directory "+f)
            continue
        if not f.endswith('~'):
            do_multinote(open(f).read(),os.stat(f).st_mtime,to_real_inbox) ; debug("Uploaded "+f)
        os.remove(f)
    
def do_multinote(body,theDate,to_real_inbox):
    body = re.sub("\r\n?","\n",body.strip())
    if not body:
        debug("Not creating message from blank file")
        return
    subject,body = (body+"\n").split("\n",1)
    if to_real_inbox: box = ""
    else: box = authenticated_wrapper(subject,body)
    if box==False: box=filtered_inbox
    if not box==None: save_to(box,"From: "+imapfix_name+"\r\nSubject: "+utf8_to_header(subject)+"\r\nDate: "+email.utils.formatdate(theDate)+"\r\nMIME-Version: 1.0\r\nContent-type: text/plain; charset=utf-8\r\n\r\n"+from_mangle(body)+"\n")

def isatty(f): return hasattr(f,"isatty") and f.isatty()
if quiet==2: quiet = not isatty(sys.stdout)

def do_delete(foldername):
    foldername = foldername.strip()
    if not foldername:
        print "No folder name specified"
        return
    make_sure_logged_in()
    print "Deleting folder "+repr(foldername)
    check_ok(imap.delete(foldername))

def do_quicksearch(s):
    global quiet ; quiet = True # don't need "Logging in" etc
    for foldername in yield_folders():
        typ, data = imap.search(None, 'TEXT', '"'+s.replace("\\","\\\\").replace('"',r'\"')+'"')
        if not typ=='OK': raise Exception(typ)
        for msgID in data[0].split():
            typ, data = imap.fetch(msgID, '(RFC822)')
            if not typ=='OK': continue
            message = data[0][1]
            matching_lines = filter(lambda l:s.lower() in l.lower(), message.split('\n'))
            for m in matching_lines:
                try_print(foldername,m.strip())
    if not archive_path: return
    for f in listdir(archive_path):
        f = archive_path+os.sep+f
        if f.endswith(compression_ext): f2 = open_compressed(f[:-len(compression_ext)],'r')
        else: f2 = open(f) # ?? (shouldn't happen, as all the files we put there should end with compression_ext, but just in case; TODO other forms of compression?)
        for l in f2:
            if s.lower() in l.lower(): try_print(f,l.strip())

def try_print(folder,line):
    try:
        sys.stdout.write(folder+": "+line+"\n")
        sys.stdout.flush()
    except IOError: # probably the pager quit on us
        raise SystemExit

def shell_quote(s): return "'"+s.replace("'",r"'\''")+"'"

imap = None
def make_sure_logged_in():
    global imap, saveImap
    while imap==None:
        debug("Logging in")
        try:
            imap = saveImap = imaplib.IMAP4_SSL(hostname)
            check_ok(imap.login(username,password))
        except:
            if not login_retry: raise
            imap = None
            debug("Login failed; retry in 30 seconds")
            time.sleep(30)
def make_sure_logged_out():
    global imap, saveImap
    if not imap==None:
        debug("Logging out")
        imap.logout()
        imap = saveImap = None

def other_running():
    import commands
    ps = commands.getoutput("ps auxwww").split('\n')
    numCols = len(ps[0].split())
    lineFormat = r"^(.*[^\s])\s+([0-9]+)"+r"\s+[^\s]+"*(numCols-3)+r"\s+([^\s].*)$" # this assumes the PID will be the first numeric thing that comes after whitespace (which should cope with usernames that have whitespace in them as long as they don't have whitespace followed by number)
    thisPIDuser = "" ; otherPIDusers = set()
    for p in ps:
        m = re.match(lineFormat,p)
        if not m: continue
        user,pid,command = m.groups()
        start = command.find(sys.argv[0])
        if start<0: continue # it's not an imapfix process
        if command[start+len(sys.argv[0]):].strip(): continue # ignore imapfix process with options (or a shell command like 'imapfix;something-else')
        if start:
            before_arg0 = command[:start].strip()
            if ' ' in before_arg0 or ';' in before_arg0 or '&' in before_arg0: continue # some kind of shell command that ends up running imapfix
        # if get this far, it's *probably* an imapfix process (but not guaranteed - I did say exit_if_other_running wasn't perfect
        if pid==str(os.getpid()): thisPIDuser = user
        else: otherPIDusers.add(user)
    return thisPIDuser in otherPIDusers

callSMTP_time = None
def send_mail(to,subject_u8,txt,attachment_filenames=[],copyself=True,ttype="plain",charset="utf-8"):
    global callSMTP_time
    if callSMTP_time:
        toSleep = max(0,callSMTP_time-time.time())
        if toSleep: debug("Sleeping for another %d seconds before reconnecting to SMTP" % toSleep)
        time.sleep(toSleep)
    debug("SMTP to "+repr(to))
    msg = email.mime.text.MIMEText(re.sub('\r*\n','\r\n',txt),ttype,charset) # RFC 2822 says MUST use CRLF; some mail clients get confused by just \n (e.g. some versions of MPro on RISC OS when replying with quote)
    if attachment_filenames:
        from email.mime.multipart import MIMEMultipart
        msg2 = msg
        msg = MIMEMultipart()
        msg.attach(msg2)
    msg['Subject'] = utf8_to_header(subject_u8)
    msg['From'] = smtp_fromHeader
    msg['To'] = to # TODO: utf8_to_header the name part of it (+ what if it's a list?)
    msg['Date'] = email.utils.formatdate(time.time())
    for f in attachment_filenames:
        subMsg = email.mime.base.MIMEBase('application', 'octet-stream') # TODO: more specific types?
        subMsg.set_payload(open(f,'rb').read())
        from email import encoders
        encoders.encode_base64(subMsg)
        if os.sep in f: f=f[f.rindex(os.sep)+1:]
        subMsg.add_header('Content-Disposition', 'attachment', filename=f)
        msg.attach(subMsg)
    import smtplib
    s = smtplib.SMTP_SSL(smtp_host)
    if smtp_user: s.login(smtp_user, smtp_password)
    ret = s.sendmail(smtp_fromAddr,to,msg.as_string())
    assert len(ret)==0, "Some (but not all) recipients were refused: "+repr(ret)
    s.quit()
    if smtp_delay: callSMTP_time = time.time()+smtp_delay
    if copyself:
        if copyself_delete_attachments:
            delete_attachments(msg)
        save_to(copyself_folder_name,myAsString(msg),"\\Seen",email.utils.mktime_tz(email.utils.parsedate_tz(msg['Date'])))
import imapfix_config
imapfix_config.send_mail = send_mail

if __name__ == "__main__":
  if '--archive' in sys.argv: do_archive()
  elif '--quicksearch' in sys.argv: do_quicksearch(' '.join(sys.argv[sys.argv.index('--quicksearch')+1:]))
  elif '--delete' in sys.argv: do_delete(' '.join(sys.argv[sys.argv.index('--delete')+1:]))
  elif '--note' in sys.argv: do_note(' '.join(sys.argv[sys.argv.index('--note')+1:]))
  elif '--maybenote' in sys.argv: do_note(' '.join(sys.argv[sys.argv.index('--maybenote')+1:]),maybe=1)
  elif '--htmlnote' in sys.argv: do_note(' '.join(sys.argv[sys.argv.index('--htmlnote')+1:]),"text/html")
  elif '--multinote' in sys.argv: multinote(sys.argv[sys.argv.index('--multinote')+1:],False)
  elif '--multinote-inbox' in sys.argv: multinote(sys.argv[sys.argv.index('--multinote-inbox')+1:],True)
  elif '--once' in sys.argv:
      poll_interval = False ; mainloop()
  elif exit_if_other_running and other_running(): sys.stderr.write("Another "+imapfix_name+" already running - exitting\n(Use "+imapfix_name+" --once if you want to force a run now)\n")
  elif '--fix-archives' in sys.argv: fix_archives_written_by_imapfix_v1_308() # TODO: document this? (use if mutt can't read archives written by v1.308, and some earlier versions, TODO: check which version was the first to have the 'writes a malformed envelope-From' problem)
  else: mainloop()
  make_sure_logged_out()
